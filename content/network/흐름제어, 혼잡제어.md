# TCP/IP 흐름제어 & 혼잡제어

**흐름제어(Flow Control)** 와 **혼잡제어(Congestion Control)** 는 전송 속도를 조절하여 **데이터 손실과 지연을 방지**하는 핵심 메커니즘

---

## 1. Reliable Network 보장의 핵심 문제 4가지
1. **손실(Packet Loss)**: 전송 중 패킷이 사라질 수 있음  
2. **순서 바뀜(Packet Reordering)**: 도착 순서가 섞일 수 있음  
3. **혼잡(Congestion)**: 네트워크가 과부하됨  
4. **오버로드(Overload)**: 수신자가 처리 능력을 초과함  

---

## 2. 흐름제어 (Flow Control)
수신 측의 처리 속도가 송신 측보다 느릴 경우 발생하는 문제를 해결하는 메커니즘
- **목표**: 송신자가 수신자의 처리 능력에 맞춰 데이터 전송량 조절  

### 2.1 대표 기법
#### 1) Stop and Wait
- 매 전송 패킷에 대해 **ACK 확인 후** 다음 패킷 전송  
- **단점**: 비효율적, 한 번에 하나씩 전송  

#### 2) Sliding Window
- **윈도우** 크기 만큼 패킷을 연속 전송 가능

  -  **Window** :송신자가 ACK를 기다리지 않고 한 번에 전송할 수 있는 최대 데이터 양
  -  TCP/IP를 사용하는 모든 호스트들은 송신하기 위한 것과 수신하기 위한 2개의 Window를 가지고 있다.
  -  흐름제어에서 최초의 윈도우 크기는 호스트들의 '3 way handshaking'을 통해 수신 측 윈도우 크기로 설정

<p align="center">
<img width="580" height="322" alt="image" src="https://github.com/user-attachments/assets/bed841a4-34c6-46f0-889b-43450a6c39d1" />
</p>

- **동작 원리**:
  - 윈도우 내 패킷 전송 후 ACK 수신 시 윈도우 이동  
  - ACK 번호 = “다음에 받아야 할 바이트 번호”  
  - 예시:  
    ```
    송신 데이터: 0, 1 전송
    수신 ACK: 2 → "0, 1 정상 수신"
    윈도우 2칸 이동 → 다음 데이터 전송 가능
    ```
- **핵심 원리**:
  
LastByteSent - LastByteAcked <= ReceiveWindow

| 용어 | 의미 |
|------|------|
| **LastByteSent** | 송신자가 지금까지 보낸 **마지막 바이트 번호** |
| **LastByteAcked** | 수신자로부터 **ACK(확인 응답)을 받은 마지막 바이트 번호** |
| **ReceiveWindow (RcvWindow)** | 수신자가 한 번에 처리할 수 있는 **버퍼 여유 공간(최대 윈도우 크기)** |


**→ 미확인 데이터량이 수신자 버퍼보다 크면 안 됨**

---

## 3. 혼잡제어 (Congestion Control)
네트워크 과부하를 방지하기 위한 송신 속도 조절 메커니즘  

**혼잡제어** 관점에서 Window :

송신자가 **네트워크 혼잡 상태를 고려해 전송할 수 있는 가상의 윈도우 크기**

### 3.1 대표 기법
#### 1) AIMD (Additive Increase / Multiplicative Decrease)
- 문제 없으면 윈도우 크기 **1씩 증가**, 문제 발생 시 **반으로 감소**  
- 단점: 윈도우 증가 속도가 느려 대역폭 활용까지 시간이 걸림  

#### 2) Slow Start (느린 시작)
- 윈도우 크기: 1 → 2 → 4 → 8 ... 지수적 증가  
- 혼잡 감지 시 윈도우 크기를 1로 초기화  
- 장점: ACK 도착 시 윈도우 증가, 점차 전송 속도 상승  

#### 3) Fast Retransmit (빠른 재전송)
<p align="center">
<img width="580" height="322" alt="image" src="https://github.com/user-attachments/assets/e740f145-0e34-4322-bb4c-062fea2517bf" />
</p>

- **중복 ACK 3회**를 손실 신호로 간주하고 즉시 재전송  
- 타이머 만료를 기다리지 않음 → 손실 감지 시간 단축, 효율 향상  

#### 4) Fast Recovery (빠른 회복)
- 혼잡 발생 시 **윈도우 크기 1로 줄이지 않고 반으로 감소**, 선형 증가  
- 이후 AIMD 방식으로 동작  

---

**[참고 자료]**

- [링크](https://steady-coding.tistory.com/507)

- [링크](https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html)


