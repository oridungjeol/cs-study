## 명령어의 기본 구조

- **명령어 = 연산 코드 + 오퍼랜드**
- **연산 코드** : 명령어가 수행할 연산 (연산자)
- **오퍼랜드** : 연산에 사용할 데이터 또는 그 데이터가 저장된 위치 (피연산자)

  <img width="600" height="239" alt="image" src="https://github.com/user-attachments/assets/cd84de02-1466-4f9f-96cc-a3b8721f1fab" />




##  오퍼랜드란?

- 연산에 사용할 데이터 또는 그 데이터가 저장된 위치
- **오퍼랜드 필드에는** 다음이 올 수 있다:
  - 숫자, 문자 (직접 데이터)
  - 메모리 주소
  - 레지스터 이름

> 📌 실제로는 연산에 사용할 데이터를 **직접 명시하기보다는**,  
> 그 데이터가 **저장된 위치(주소)** 를 명시하는 경우가 많음  
> 👉 그래서 오퍼랜드 필드를 **주소 필드(address field)** 라고도 부름

- 오퍼랜드의 개수에 따라 명령어를 다음과 같이 분류함:
  - **0-주소 명령어**
  - **1-주소 명령어**
  - **2-주소 명령어**
  - **3-주소 명령어**
<img src="https://velog.velcdn.com/images/yumin991209/post/d840c38c-de29-492d-b3f3-ed3fcce0f9ab/image.png" width="600">




## 연산 코드 (Opcode)의 종류

### 1. 데이터 전송
- `MOVE`: 데이터를 옮겨라
- `STORE`: 메모리에 저장
- `LOAD(FETCH)`: 메모리 → CPU로 데이터 가져오기
- `PUSH`: 스택에 저장
- `POP`: 스택에서 꺼내기

### 2. 산술/논리 연산
- `ADD`, `SUBTRACT`, `MULTIPLY`, `DIVIDE`
- `INCREMENT`, `DECREMENT`
- `AND`, `OR`, `NOT`
- `COMPARE`: 두 값 비교

### 3. 제어/흐름 변경
- `JUMP`, `CONDITIONAL JUMP`, `HALT`
- `CALL`, `RETURN`

### 4. 입출력 제어
- `READ`, `WRITE`
- `START IO`, `TEST IO`



## 주소 지정 방식이 필요한 이유

**왜 데이터를 직접 명시하지 않고, 그 위치(주소)를 명시할까?**

예시:
<img src="https://velog.velcdn.com/images/yumin991209/post/708633b7-65cc-4050-9283-b4d0bcb33824/image.png" width="600">



- 명령어 크기: 16비트  
- 연산 코드: 4비트  
- 오퍼랜드 3개 → 하나당 4비트  
  → **2⁴ = 16개**밖에 정보 표현 불가
 

➡ 메모리 주소를 명시하면?  
<img src="https://velog.velcdn.com/images/yumin991209/post/ba7b5a9c-a795-44a8-9053-df0cd132ff36/image.png" width="600">


- 메모리가 한 주소에 16비트 저장 가능하다고 가정 시  
- **2¹⁶ = 65,536**가지 데이터 접근 가능

🔑 **요점**:  
직접 데이터를 명시하는 것보다 **주소를 명시**하는 것이  
더 많은 데이터를 다룰 수 있게 해준다.



##  주소 지정 방식(Addressing Modes)과 유효 주소

- **유효 주소 (Effective Address)**  
  : 연산 코드에 사용할 데이터가 저장된 위치  
  → 즉, **연산의 대상이 되는 데이터가 저장된 위치**

- **주소 지정 방식 (Addressing Mode)**  
  : **유효 주소를 찾는 방법**



## 1. 즉시 주소 지정 방식 (Immediate Addressing)
<img src="https://velog.velcdn.com/images/yumin991209/post/269bde01-f3f9-4dde-8186-a0703ac5e0a7/image.png" width="400">

- 연산에 사용할 데이터를 **오퍼랜드 필드에 직접 명시**
- 가장 단순한 주소 지정 방식
- 연산에 사용할 데이터의 크기가 작아질 수 있지만, 빠름
  
- ✅ **장점**: 빠르다  
- ❌ **단점**: 표현 가능한 데이터의 크기가 작음



## 2. 직접 주소 지정 방식 (Direct Addressing)
<img src="https://velog.velcdn.com/images/yumin991209/post/e54f1ec8-0671-41b3-8130-e1dac1e23067/image.png" width="600">

- 오퍼랜드 필드에 **유효 주소(메모리 주소)** 를 직접 명시
- 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦
  
- ✅ **장점**: 단순하고 직관적
- ❌ **단점**: 유효 주소 표현 범위에 제한이 생김



## 3. 간접 주소 지정 방식 (Indirect Addressing)
<img src="https://velog.velcdn.com/images/yumin991209/post/bb454a15-c856-4bf1-8bc3-a1e8738fa15d/image.png" width="600">


- 오퍼랜드 필드에 **유효 주소의 주소**를 명시
- 실제 데이터가 있는 주소를 한 번 더 참조해야 함
  
- ✅ **장점**: 더 넓은 주소 범위 사용 가능
- ❌ **단점**: **두 번의 메모리 접근** → 느림



## 4. 레지스터 주소 지정 방식 (Register Addressing)
<img src="https://velog.velcdn.com/images/yumin991209/post/146123b5-19f7-4bd4-a93d-3d0786a7aed0/image.png" width="600">


- 연산에 사용할 데이터가 **레지스터에 저장**되어 있음
- 오퍼랜드 필드에 **레지스터 이름**을 명시
- 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름
  
- ✅ **장점**: 매우 빠름 
- ❌ **단점**: 사용 가능한 레지스터 수에 제한 있음


## 5. 레지스터 간접 주소 지정 방식 (Register Indirect Addressing)
<img src="https://velog.velcdn.com/images/yumin991209/post/c054e8b5-8fcb-488a-91b0-ccb766d7a376/image.png" width="600">>


- 연산에 사용할 데이터를 **메모리에 저장**
- 그 주소를 저장한 **레지스터를 오퍼랜드 필드에 명시**
  
- ✅ **장점**: 메모리 접근은 1회 → 간접 주소보다 빠름
- ❌ **단점**: 구조가 다소 복잡할 수 있음

---

## 🧾 정리

- 연산에 사용할 데이터를 **찾는 방법** = **주소 지정 방식**
- 연산에 사용할 데이터가 **저장된 위치** = **유효 주소**


### 📌 오퍼랜드 필드에 명시하는 값에 따른 분류

| 주소 지정 방식              | 오퍼랜드 필드에 명시하는 것           | 장점                     | 단점                    |
| -------------------------- | ---------------------------------- | ------------------------ | ----------------------- |
| 즉시 (Immediate)           | 연산에 사용할 **데이터 자체**         | 빠름                     | 표현 크기 제한              |
| 직접 (Direct)              | **유효 주소**                         | 단순함                   | 주소 크기 제한 가능           |
| 간접 (Indirect)            | **유효 주소의 주소**                   | 유효 주소 범위 넓음        | 메모리 접근 2회 → 느림        |
| 레지스터 (Register)         | **레지스터 이름**                     | 빠름 (CPU 내부 접근)       | 레지스터 수 제한             |
| 레지스터 간접 (Reg Indir)  | **유효 주소를 저장한 레지스터**         | 빠름 + 주소 표현력 보존     | 약간의 복잡성               |




## 📚 참고/출처
참고 강의 : [개발자를 위한 컴퓨터공학 1: 혼자 공부하는 컴퓨터구조 + 운영체제 – 인프런 강의](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

참고 도서:  『혼자 공부하는 컴퓨터 구조+운영체제』 – 강민철 지음, 한빛미디어, 2023

