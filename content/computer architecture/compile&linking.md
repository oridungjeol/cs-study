# 컴파일과 링킹: 고급언어에서 실행파일까지의 과정

## 1. 고급언어와 저급언어

우리가 쓰는 **C**, **Java** 같은 언어는 사람이 이해하기 쉽게 만든 **고급 언어**.  
컴퓨터가 직접 이해하는 언어는 0과 1로 된 **기계어** 같은 **저급 언어**.

> **고급 언어로 쓴 코드는 반드시 저급 언어로 변환되어야 실행할 수 있다.**



## 2. 저급 언어 종류

- **기계어**: 0과 1로 이루어진 컴퓨터가 직접 실행하는 언어
- **어셈블리어**: 기계어를 사람이 읽기 쉽게 기호로 표현한 언어



## 3. 고급 언어가 저급 언어로 변환되는 두 가지 방식

고급 언어로 작성한 소스 코드는 결국 저급 언어(기계어)로 변환되어 실행됨.  
그 변환 방식은 크게 두 가지로 나뉨:

- **컴파일 방식**
- **인터프리터 방식**



### 1) 컴파일 언어

- 컴파일 방식으로 작동하는 프로그래밍 언어.
- 컴파일러가 **소스 코드 전체를 한 번에 저급 언어로 변환**.
- 대표적인 컴파일 언어: **C**

#### 컴파일 과정

- 컴파일러가 소스 코드를 처음부터 끝까지 검사하며 문법 오류와 실행 가능 여부를 확인.
- 오류가 없으면 전체 코드를 기계어로 변환하여 **목적 코드** 생성.

#### 장단점

- 변환된 실행 파일은 CPU가 바로 실행 가능해 **빠른 속도 제공**  
- 컴파일 시간 필요, 오류 발생 시 전체 코드를 다시 컴파일해야 함



### 2) 인터프리터 언어

- 인터프리터 방식으로 작동하는 프로그래밍 언어.
- 인터프리터가 **소스 코드를 한 줄씩 순차적으로 읽고 해석하여 실행**.
- 대표적인 인터프리터 언어: **Python**

#### 실행 과정

- 코드를 한 줄씩 저급 언어로 변환하며 즉시 실행.
- 코드 중간에 오류가 있어도, 오류 이전까지는 실행 가능.

#### 장단점

- 실행 전 전체 컴파일 과정이 없어 즉시 실행 가능하며 디버깅이 편리  
- 실행 시 계속 해석 작업을 해야 해서 실제 실행 속도는 느림


## 4. 컴파일 언어 vs 인터프리터 언어

| 구분             | 인터프리터 언어               | 컴파일 언어                      |
|------------------|------------------------------|----------------------------------|
| 실행 전          | 해석만, 즉시 실행 가능        | 전체를 기계어로 변환(컴파일) 필요 |
| 첫 실행 속도     | **빠름 (바로 실행)**          | 느림 (컴파일 시간 필요)          |
| 실제 실행 속도   | 느림 (계속 해석)              | **빠름 (바로 기계어 실행)**       |
| 개발/디버깅      | 편리, 즉시 결과 확인          | 수정 후 다시 컴파일 필요          |

#### 요약

- 컴파일 언어는 **실행 파일을 미리 만들어 두어 실행 속도가 빠름**.
- 인터프리터 언어는 **즉시 실행 가능하지만 실행 중 해석 때문에 느림**.
- 개발자 용도와 목적에 따라 적합한 방식을 선택하여 사용함.


## 5. 목적 파일 vs 실행 파일

- **목적 코드** = 컴파일러를 통해 저급 언어(기계어)로 변환된 코드.
- 목적 코드로 이루어진 파일을 **목적 파일**이라고 한다.

 **목적 파일은 실행 파일을 만들기 위한 중간 단계의 파일**로써  
아직 완전한 프로그램이 아니기 때문에 바로 실행할 수 없다.  
필요한 라이브러리 및 다른 목적 코드들과 결합해서 **실행 파일**로 만들어야 하며  
이 과정을 **링킹(Linking)** 이라고 한다.



## 6. 링킹(Linking)

 **링킹의 정의**  
링킹은 여러 개의 목적 파일(`.o`, `.obj`)과 라이브러리들을 연결해서  
운영체제가 바로 실행할 수 있는 실행 파일(`.exe`, ELF)을 만드는 과정.

>  **링킹 =**  
>  서로 흩어진 코드 조각(목적 파일)과 라이브러리를  
>  하나로 묶어서  
>  실행 가능한 완제품(실행 파일)으로 만드는 작업



## 7. 컴파일 및 링킹 과정

### 예시

**main.c**
```c
void hello();  
int main() {
    hello();
    return 0;
}
```
**hello.c**
```c
#include <stdio.h>

void hello() {
    printf("Hello, world!\n");
}
```
### 1️⃣ 컴파일 단계 (Compile)

- **입력**: 소스 코드 (`main.c`, `hello.c` 등)
- **출력**: 목적 파일 (`main.o`, `hello.o`)
- 각 소스 파일은 독립적으로 기계어로 번역됨.

**main.c 컴파일 결과 (main.o)에는:**
-  main 함수 심볼과 코드가 있고,
-  hello 함수가 호출되지만 구현은 없으므로 hello라는 심볼 이름만 참조(symbol reference)로 존재.
  
<img src="https://velog.velcdn.com/images/yumin991209/post/07bae9e4-f3bb-40d5-9251-30ca11bd5e17/image.png" width="300">



**hello.c 컴파일 결과 (hello.o)에는:**
- hello 함수 심볼과 함수 구현 코드가 들어 있음.
- printf 함수는 외부 라이브러리 함수이므로 심볼 이름만 참조됨.

 **심볼(symbol)**  
> → 컴퓨터 프로그램에서 함수 이름이나 변수 이름 같은  
> → 사람이 읽을 수 있는 이름을 뜻함.


 <br>

### 2️⃣ 심볼 테이블 생성

- 목적 파일 안에는 **심볼 테이블(symbol table)** 이 들어있음.
- 심볼 테이블에는 다음 내용이 포함됨:
  - 정의된 심볼(함수, 변수) 목록
  - 참조된 심볼 목록(외부에 있는 함수, 변수 이름)
- 이 단계에서는 심볼 이름만 있고 주소는 아직 미정.

| 심볼 이름 | 종류     | 메모리 주소  |
|-----------|----------|----------------------|
| main      | 함수     |       |
| hello     | 함수     |         |
| printf    | 함수(외부)|       |

<br>

### 3️⃣ 링킹 준비 (Linking Preparation)

- 링커는 여러 목적 파일과 라이브러리를 모아서
- 심볼 테이블을 분석하고, 서로 참조하는 심볼을 찾아 연결 준비를 함.

<br>

### 4️⃣ 심볼 해결 (Symbol Resolution)

- 링커가 “이 함수, 이 변수는 어디에 있는지” 찾음.

**예:**
- `main.o`의 `hello()` 호출 → `hello.o`에서 `hello()` 함수 찾음.
- `hello.o`의 `printf()` 호출 → 표준 라이브러리(libc)에서 `printf` 찾음.

<br>

### 5️⃣ 주소 배치 (Address Layout)

- 링커가 목적 파일과 라이브러리 코드를 메모리에 올릴  
  **가상 주소(논리 주소)** 위치를 결정.
- 각 함수와 변수에 가상 주소를 할당함.

<br>

### 6️⃣ 재배치 (Relocation)

- 목적 파일 내부의 기계어 코드 중에서 아직 심볼 이름으로 남아있던 부분에  
  ➡️ 링커가 결정한 가상 주소를 ‘적용’ (즉, 실제 주소 값으로 변경)함.

<img src="https://velog.velcdn.com/images/yumin991209/post/8e900442-bfa0-43b8-acba-8ac425daa4f0/image.png" width="300">


| 심볼 이름 | 종류     | 메모리 주소 (초기)   | 메모리 주소 (할당 후)          |
|-----------|----------|----------------------|-------------------------------|
| main      | 함수     | (없음 또는 0)        | 0x00401200                    |
| hello     | 함수     | (없음 또는 0)        | 0x00401350                    |
| printf    | 함수(외부)| (없음 또는 0)       | 0x7ffdf000 (외부 라이브러리)  |


링커가 hello 함수에 가상 주소 0x00401350를 할당하면,
기계어 코드 내에서 hello라는 심볼 참조는 실제 주소 0x00401350로 변경돼서 호출 명령어가 올바르게 작동한다.

하지만!

심볼 테이블에서는 여전히 심볼 이름은 hello로 남아 있고, 그 심볼에 대응하는 주소 값으로 0x00401350이 기록되어 있음.
즉, 심볼 테이블은 hello → 0x00401350의 매핑 정보를 유지하는 ‘사전’ 역할을 계속 하는 것.
  
<br>

### 7️⃣ 실행 파일 생성 (Executable Generation)

- 링커가 모든 코드와 데이터를 하나로 묶어서
- 운영체제가 실행할 수 있는 실행 파일(예: `.exe`)을 만듦.

<br>

### 8️⃣ 실행 (Run)

- 운영체제가 실행 파일을 메모리에 로드하고
- CPU가 기계어 명령을 수행해서 프로그램이 실행됨.
